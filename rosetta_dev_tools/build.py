#!/usr/bin/env python3

"""\
Compile rosetta.

Note that CMake decides which compiler to use by looking at the $CC and $CXX 
environment variables when the configuration file is initially built.  So if 
you don't want to use whichever compiler CMake picks by default, set these 
variables and rebuild rosetta from scratch.

Usage:
    rdt_build [<build>] [<project>] [options]

Options:
    -f, --clean
        Remove all the files generated by previous compilations.  

    -j, --jobs NUM
        The number of compilation jobs to run concurrently to use.  By default, 
        ninja will choose a number based on how many CPUs your machine has.

    -v, --verbose
        Output each command line that gets run, in case something needs to be 
        debugged.
"""

import sys, os
from . import helpers

def main():
    import docopt
    args = docopt.docopt(__doc__)

    try:
        error_code = build_rosetta(
                build=args['<build>'],
                project=args['<project>'],
                clean=args['--clean'],
                nprocs=args['--jobs'],
                verbose=args['--verbose'],
        )
        sys.exit(error_code)

    except KeyboardInterrupt:
        pass

    except helpers.FatalBuildError as error:
        error.exit_gracefully()

def build_rosetta(build=None, project=None, clean=False, nprocs=None, verbose=False):
    # Initialize the settings and paths that we'll use for this build.  This 
    # involves setting some default values and making sure some paths exist.

    build = build or 'debug'
    rosetta_path = helpers.find_rosetta_installation()
    cmake_path = os.path.join(rosetta_path, 'source', 'cmake')
    build_path = os.path.join(cmake_path, 'build_' + build)

    require_cmake_path(cmake_path, 'make_project.py')
    require_cmake_path(build_path, 'CMakeLists.txt')

    # Remove any files that were generated by past compilations, if the user 
    # requested that this happen.

    if clean:
        wipe_old_build(build_path)

    # Use cmake to generate the ninja build files, if necessary.  This will be 
    # necessary either if the ninja configuration doesn't exist or if the 
    # *.settings file were modified more recently than the ninja build script.

    make_project = 'python2', 'make_project.py', 'all'
    make_ninja = 'cmake', '-G', 'Ninja', '-Wno-dev'

    if is_ninja_config_stale(build_path):
        helpers.shell_command(cmake_path, make_project, verbose=verbose)
        helpers.shell_command(build_path, make_ninja, verbose=verbose)

    # Execute the ninja command to build rosetta.

    ninja_build = 'ninja-build',
    if project is not None:
        ninja_build += project,
        if not project.endswith('.test'):
            ninja_build += project + '_symlink',
    if nprocs is not None:
        ninja_build += '-j', nprocs

    return helpers.shell_command(
            build_path, ninja_build, check=False, verbose=verbose)

def wipe_old_build(build_path):
    for subpath in os.listdir(build_path):
        path = os.path.join(build_path, subpath)

        if subpath == 'CMakeLists.txt':
            continue
        elif os.path.isdir(path):
            import shutil
            shutil.rmtree(path)
        else:
            os.remove(path)

def is_ninja_config_stale(build_path):
    from glob import glob

    rosetta_path = os.path.dirname(os.path.dirname(build_path))
    ninja_config_path = os.path.join(build_path, 'build.ninja')
    src_settings_glob = os.path.join(rosetta_path, 'src', '*.settings')
    test_settings_glob = os.path.join(rosetta_path, 'test', '*.settings')

    if not os.path.exists(ninja_config_path):
        return True

    most_recent_build = os.path.getmtime(ninja_config_path)
    most_recent_modification = 0
    for path in glob(src_settings_glob) + glob(test_settings_glob):
        most_recent_modification = max(
                os.path.getmtime(path), most_recent_modification)

    return most_recent_modification > most_recent_build

def require_cmake_path(cmake_path, *sub_paths):
    full_path = os.path.join(cmake_path, *sub_paths)
    if not os.path.exists(full_path):
        raise MissingCMakeFiles(*sub_paths)

class MissingCMakeFiles (helpers.FatalBuildError):
    exit_status = 2
    exit_message = """\
            Could not find '{0}'.  This might indicate that this script was 
            unable to properly locate your Rosetta installation, or it may 
            indicate that your installation has somehow been corrupted. """

    def __init__(self, *sub_paths):
        path = os.path.join('source', 'cmake', *sub_paths)
        FatalBuildError.__init__(self, path)


